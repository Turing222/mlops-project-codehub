#定义企业级日志格式 (main)
log_format enhanced_main '$remote_addr - $remote_user [$time_local] "$request" '
                '$status $body_bytes_sent "$http_referer" '
                '"$http_user_agent" "$http_x_forwarded_for" '
                'rt=$request_time uct="$upstream_connect_time" uat="$upstream_addr" '
                'rid="$http_x_request_id"'; # 顺便把我们之前的 Request ID 也打进去
# 定义后端服务池 (Upstream)
upstream backend_servers {
    # 轮询 (Round Robin) 是默认策略
    least_conn;
    server api:8000 max_fails=3 fail_timeout=30s;
    keepalive 32;

    # DBA 视角：如果需要会话保持，可以开启 ip_hash
    # ip_hash; 
}
server {
    listen 80;
    server_name mentor.test;
    return 301 https://$host$request_uri;
}
server {
#    listen 80;
#    server_name localhost;
    listen 443 ssl http2;
    server_name mentor.test;

    # 指向容器内的路径（刚才 volumes 映射的位置）
    ssl_certificate     /etc/nginx/ssl/ssl.crt;
    ssl_certificate_key /etc/nginx/ssl/ssl.key;

    # SSL 优化配置（DBA 建议：减少握手开销，保住你的内存）
    ssl_session_cache    shared:SSL:10m;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_session_timeout  5m;
    ssl_prefer_server_ciphers  on;


# 2. 启用该格式的日志
    access_log /var/log/nginx/access.log enhanced_main;
    error_log /var/log/nginx/error.log warn;

    location / {
        root /usr/share/nginx/html;
        index index.html index.htm;
        # 核心：如果找不到资源，统一指向 index.html，让 React Router 接管路由
        try_files $uri $uri/ /index.html;
    }

    # 反向代理：解决跨域问题，将 /api 开头的请求转发到后端
    location /api/ {
        # 1. 在入口处生成或透传 Request ID
        proxy_set_header X-Request-ID $request_id;
        
        # 2. 基础透传 (注意末尾的斜杠，会去掉 /api 前缀)
        proxy_pass http://backend_servers/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        # 3. 路径重写
        #3rewrite ^/api/(.*)$ /$1 break;

        # 4. 针对 LLM 流式响应的优化 (Ollama 必备)
        proxy_http_version 1.1;       # 必须用 HTTP/1.1 才能支持长连接
        proxy_set_header Connection ""; #配合 keepalive
        proxy_buffering off;          # 关闭缓冲区！否则 Nginx 会攒够一波数据才发给前端，流式效果会卡顿
        proxy_cache off;              # AI 响应通常不缓存

        # 超时控制：给 AI 思考预留时间
        proxy_read_timeout 300s;
        proxy_send_timeout 300s;
        # 禁用 Nginx 的响应解析，让数据直接吐给前端
        proxy_ignore_client_abort on;
    }
}